# 리액트에서는_어떻게_캡쳐링_단계_이벤트_처리를_하는지

클로드와 함께 이벤트 매니저 코드를 개선하는 중 다음과 같은 형태의 코드를 작성했습니다.
```typescript
import { HTMLEventName } from "@/types/event";
import { htmlEventNames } from "@/constants/htmlEventsName";

// 이벤트 핸들러와 관련 설정을 저장할 타입 정의
interface EventListener {
  capture: boolean; // 캡처링 단계에서 처리할지 여부
  handler: (e: SyntheticEvent) => void; // 실제 이벤트 핸들러
}

// React 처럼 브라우저간 일관된 이벤트 객체를 제공하기 위한 인터페이스
interface SyntheticEvent extends Event {
  nativeEvent: Event; // 원본 DOM 이벤트 참조 보관
  isPropagationStopped(): boolean; // 이벤트 전파 중단 여부 확인
  stopPropagation(): void; // 이벤트 전파 중단 메서드
}

// WeakMap 을 사용해 메모리 누수를 방지하며 이벤트 리스너 저장
let listeners: Partial<
  Record<HTMLEventName, WeakMap<HTMLElement, EventListener>>
> = {};

// 이벤트 시스템 초기 설정
export function setupEventListeners($root: HTMLElement) {
  // 기존에 등록된 리스너들을 모두 제거 (메모리 누수 방지)
  htmlEventNames.forEach((eventType) => {
    $root.removeEventListener(eventType, handleGlobalEvent, false);
  });

  // 새로운 리스너 등록
  registerGlobalEvent($root);
}

// 이벤트 리스너 등록 함수
export function addEvent(
  element: HTMLElement,
  eventType: HTMLEventName,
  handler: (e: SyntheticEvent) => void,
  capture: boolean = false, // 기본값은 버블링 단계
) {
  // 해당 이벤트 타입의 WeakMap 이 없다면 생성
  if (!listeners[eventType]) {
    listeners[eventType] = new WeakMap();
  }
  // 요소와 핸들러 정보를 WeakMap 에 저장
  listeners[eventType].set(element, { capture, handler });
}

// 이벤트 리스너 제거 함수
export function removeEvent(element: HTMLElement, eventType: HTMLEventName) {
  listeners[eventType]?.delete(element);
}

// 전역 이벤트 리스너 등록
function registerGlobalEvent($root: HTMLElement) {
  htmlEventNames.forEach((eventType) => {
    // 버블링 단계의 리스너 등록
    $root.addEventListener(eventType, handleGlobalEvent, false);
  });
}

// 실제 이벤트를 처리하는 핸들러
function handleGlobalEvent(e: Event) {
  // 이벤트가 발생한 요소부터 시작해서 부모로 올라가며 처리
  let currentTarget: HTMLElement | null = e.target as HTMLElement;
  const eventType = e.type as HTMLEventName;

  // DOM 트리를 따라 올라가며 각 요소의 이벤트 핸들러 실행
  while (currentTarget) {
    const handler = listeners[eventType]?.get(currentTarget)?.handler;
    if (handler) {
      // 합성 이벤트 생성 및 핸들러 호출
      const syntheticEvent = createSyntheticEvent(e);
      handler(syntheticEvent);

      // stopPropagation 이 호출됐다면 이벤트 전파 중단
      if (syntheticEvent.isPropagationStopped()) {
        break;
      }
    }
    currentTarget = currentTarget.parentElement;
  }
}

// 합성 이벤트 객체를 생성하는 함수
function createSyntheticEvent(nativeEvent: Event): SyntheticEvent {
  let isPropagationStopped = false;

  // 원본 이벤트를 감싸서 합성 이벤트 생성
  return {
    ...nativeEvent,
    nativeEvent, // 원본 이벤트 참조 보관
    // 이벤트 전파 중단 여부 확인
    isPropagationStopped: () => isPropagationStopped,
    // 이벤트 전파를 중단시키는 메서드
    stopPropagation: () => {
      isPropagationStopped = true;
      nativeEvent.stopPropagation();
    },
  } as SyntheticEvent;
}
```

이 코드를 보면서 든 생각이 있습니다.

| 이러면 캡쳐링 단계의 이벤트를 처리할 수 없지 않나?

이에 대한 질문을 했고 얻은 답변 입니다.

맞습니다. 캡처링 단계에서만 실행되어야 하는 이벤트 핸들러도 필요할 수 있습니다.

리액트는 이를 위해 특별한 이벤트 이름을 제공합니다:
```javascript
// 일반적인 버블링 이벤트
<div onClick={handler}>

// 캡처링 이벤트
<div onClickCapture={handler}>
```

우리도 비슷한 방식으로 구현할 수 있습니다:

```typescript
// EventListener 인터페이스에 capture 플래그 활용
interface EventListener {
  capture: boolean;
  handler: (e: SyntheticEvent) => void;
}

// 이벤트 처리 핸들러 수정
function handleGlobalEvent(e: Event, isCapturing: boolean) {
  let currentTarget: HTMLElement | null = e.target as HTMLElement;
  const eventType = e.type as HTMLEventName;

  // 현재 단계(캡처링/버블링)에 해당하는 핸들러만 실행
  while (currentTarget) {
    const listener = listeners[eventType]?.get(currentTarget);
    if (listener && listener.capture === isCapturing) {
      const syntheticEvent = createSyntheticEvent(e);
      listener.handler(syntheticEvent);
      
      if (syntheticEvent.isPropagationStopped()) {
        break;
      }
    }
    currentTarget = currentTarget.parentElement;
  }
}

// 각 단계별 핸들러 생성
function createPhaseHandler(isCapturing: boolean) {
  return (e: Event) => handleGlobalEvent(e, isCapturing);
}

// 이벤트 리스너 등록 함수 수정
function registerGlobalEvent($root: HTMLElement) {
  htmlEventNames.forEach((eventType) => {
    // 캡처링과 버블링 각각의 핸들러 등록
    $root.addEventListener(eventType, createPhaseHandler(true), true);
    $root.addEventListener(eventType, createPhaseHandler(false), false);
  });
}
```

이렇게 하면:
1. 캡처링/버블링 각 단계의 이벤트를 따로 처리할 수 있음
2. 각 단계에서 한 번씩만 핸들러가 호출됨
3. 원하는 단계에서만 이벤트가 처리됨

사용 예시:
```typescript
// 버블링 단계 이벤트
addEvent(element, "click", handler, false);

// 캡처링 단계 이벤트
addEvent(element, "click", handler, true);
```
