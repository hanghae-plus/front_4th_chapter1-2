기존 코드
```typescript
function registerGlobalEvent($root: HTMLElement) {
  htmlEventNames.forEach((eventType) => {
    $root.addEventListener(eventType, handleGlobalEvent, false);
  });
}

// 이벤트 버블링으로 관리해야 하는데 되고 있는게 맞긴 한가?
function handleGlobalEvent(e: Event) {
  const { type, target } = e;
  const handler = listeners[type]?.get(target);
  if (handler) return handler(e);
  e.stopPropagation();
}
```

현재 코드의 주요 문제점은 이벤트 위임의 핵심 기능인 "부모 요소들의 이벤트 핸들러 처리"가 누락되어 있다는 것입니다.

예를 들어:
```javascript
<div onClick={divHandler}>
  <button onClick={buttonHandler}>클릭</button>
</div>
```

현재 코드로는:
```typescript
function handleGlobalEvent(e: Event) {
  const { type, target } = e;
  // target(button)의 핸들러만 찾아서 실행
  const handler = listeners[type]?.get(target);
  if (handler) return handler(e);
  e.stopPropagation();
}
```
- button을 클릭하면 buttonHandler만 실행
- divHandler는 실행되지 않음
- e.stopPropagation()이 불필요하게 호출됨

수정된 버전:
```typescript
function handleGlobalEvent(e: Event) {
  let currentTarget = e.target as HTMLElement;
  const type = e.type as HTMLEventName;

  // DOM 트리를 따라 올라가며 모든 핸들러 실행
  while (currentTarget) {
    const handler = listeners[type]?.get(currentTarget);
    if (handler) {
      handler(e);
    }
    currentTarget = currentTarget.parentElement;
  }
}
```

이렇게 하면:
1. 이벤트가 발생한 요소의 핸들러 실행
2. 부모 요소들의 핸들러도 순차적으로 실행
3. 실제 DOM 이벤트 버블링과 동일한 동작

단순히 target의 핸들러만 찾는 방식은 이벤트 위임의 장점을 제대로 활용하지 못합니다.
